from enum import Enum

from langchain.schema import BaseMessage

from src.chat.message import Message


class Sender(Enum):
    AI = "ai"
    USER = "human"
    SYSTEM = "system"

    def __eq__(self, other):
        return self.value == other.value


class MessageUI(Message):
    """
    This class allows to separate the usage of streamlit function from the message class
    This way a user can work with the message class without having to use streamlit
    """

    def __init__(self, message: BaseMessage, **kwargs):
        super().__init__(message, **kwargs)
        self.show_full_message: bool = False

    @property
    def sender(self) -> Sender:
        return Sender(self.message.type)

    def __str__(self):
        return f"{self.sender}: {self.content}"

    def show(self, id_):
        raise NotImplementedError("This method should be implemented in the subclasses")

    @classmethod
    def from_base_message(cls, message: BaseMessage, **kwargs):
        if message.type == Sender.AI.value:
            from src.chat.ui.fake_ai_message_ui import FakeAIMessageUI  # not clean

            return FakeAIMessageUI(message=message, **kwargs)
        if message.type == Sender.USER.value:
            from src.chat.ui.human_message_ui import HumanMessageUI

            return HumanMessageUI(
                message=message,
                user_input=message.additional_kwargs.get(
                    "user_input", "<auto-generated>"
                ),
                **kwargs,
            )
        if message.type == Sender.SYSTEM.value:
            from src.chat.ui.system_message_ui import SystemMessageUI

            return SystemMessageUI(message=message, **kwargs)
        return cls(message=message, **kwargs)
